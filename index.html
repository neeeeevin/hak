<!--
File: orientation-hackathon/index.html
Purpose: Single-file mobile-first web app for the "Prompt This Into Existence!" Hackathon.

Contents:
- Mobile-first responsive UI (Tailwind CDN)
- Orientation detection (screen.orientation & window.orientation fallback)
- Four modes mapped to orientations:
  * 0   => portrait-up (Alarm)
  * 180 => portrait-down (Timer)
  * 90  => landscape-right (Stopwatch)
  * 270 => landscape-left (Weather of the Day)

- Weather: uses OpenWeatherMap (replace YOUR_OPENWEATHERMAP_API_KEY)
- Alarm: set a time; plays audio when triggered (works while page is active)
- Stopwatch: start / pause / lap / reset
- Timer: set minutes/seconds, start / pause / reset
- Smooth transitions, animated SVGs, touch-friendly controls

AI / Prompting notes (short):
- Prompts that helped:
  1) "Create a mobile-first single-page HTML/CSS/JS web app that detects device orientation and switches views for alarm, stopwatch, timer and weather. Use Tailwind and keep to a single file." -> generated base layout and orientation logic
  2) "Provide accessible, touch-friendly controls and smooth CSS/JS transitions for switching modes on orientation change." -> improved UI and animations
- Failed / iterated prompts:
  1) Asking generative model to "auto-detect exact phone rotation using DeviceOrientationEvent" produced noisy beta/gamma values on iOS; fallback to screen.orientation.angle is more reliable.

Replace the placeholder API key in the JS with your OpenWeatherMap API key.
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Prompt This Into Existence — Orientation Toolkit</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Small custom styles to complement Tailwind */
    html,body,#app{height:100%}
    body{background:linear-gradient(180deg,#0f172a,#021124);color:#e6eef8;font-family:Inter,ui-sans-serif,system-ui}
    .mode-card{backdrop-filter: blur(6px);background:linear-gradient(90deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));border:1px solid rgba(255,255,255,0.06)}
    .glass-btn{background:linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));border:1px solid rgba(255,255,255,0.06)}
    .soft-shadow{box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    .pulse {animation: pulse 1.8s infinite}
    @keyframes pulse {0%{transform:scale(1)}50%{transform:scale(1.02)}100%{transform:scale(1)}}
  </style>
</head>
<body>
  <div id="app" class="min-h-screen flex flex-col items-center justify-start p-4">
    <header class="w-full max-w-xl mt-6">
      <div class="flex items-center justify-between">
        <h1 class="text-2xl font-semibold">Orientation Toolkit</h1>
        <div class="text-sm text-slate-300">Mobile-first — demo</div>
      </div>
      <p class="text-slate-400 mt-1 text-sm">Rotate your device to switch modes. Smooth transitions and touch-friendly controls.</p>
    </header>

    <main class="w-full max-w-xl mt-6 flex-1 flex flex-col gap-4">
      <!-- Mode banner -->
      <div id="modeBanner" class="mode-card p-4 rounded-2xl soft-shadow">
        <div class="flex items-center justify-between">
          <div>
            <div id="modeTitle" class="text-lg font-semibold">Detecting orientation…</div>
            <div id="modeSubtitle" class="text-sm text-slate-300 mt-1">Keep device steady for best detection</div>
          </div>
          <div class="text-right">
            <div id="angleDisplay" class="text-xs text-slate-400">angle: --</div>
            <div id="orientationType" class="text-xs text-slate-400">type: --</div>
          </div>
        </div>
      </div>

      <!-- Mode container -->
      <div id="modes" class="relative">
        <!-- Alarm (Portrait up) -->
        <section id="alarm" class="mode-panel p-6 rounded-2xl mode-card transition-opacity duration-500 ease-in-out">
          <div class="flex items-center justify-between">
            <div>
              <h2 class="text-xl font-bold">Alarm</h2>
              <p class="text-slate-300 text-sm">Portrait Upright — Set an alarm time</p>
            </div>
            <div>
              <svg class="w-16 h-16 text-amber-400" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 8v4l2 2m6-2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
            </div>
          </div>

          <div class="mt-4 grid grid-cols-1 sm:grid-cols-2 gap-3">
            <input id="alarmTime" type="time" class="p-3 rounded-lg glass-btn w-full text-black" />
            <button id="setAlarmBtn" class="p-3 rounded-lg text-white bg-amber-500 hover:bg-amber-600">Set Alarm</button>
          </div>
          <div class="mt-3 text-sm text-slate-300">Status: <span id="alarmStatus">No alarm set</span></div>
        </section>

        <!-- Stopwatch (Landscape right) -->
        <section id="stopwatch" class="mode-panel p-6 rounded-2xl mode-card hidden transition-opacity duration-500 ease-in-out">
          <div class="flex items-center justify-between">
            <div>
              <h2 class="text-xl font-bold">Stopwatch</h2>
              <p class="text-slate-300 text-sm">Landscape — Start, lap, and reset</p>
            </div>
            <div class="text-amber-400 font-mono text-2xl" id="stopwatchDisplay">00:00.000</div>
          </div>

          <div class="mt-4 flex gap-3">
            <button id="swStart" class="flex-1 p-3 rounded-lg text-white bg-green-500">Start</button>
            <button id="swLap" class="flex-1 p-3 rounded-lg glass-btn">Lap</button>
            <button id="swReset" class="flex-1 p-3 rounded-lg glass-btn">Reset</button>
          </div>

          <ul id="laps" class="mt-3 text-slate-300 text-sm space-y-1 max-h-40 overflow-auto"></ul>
        </section>

        <!-- Timer (Portrait upside-down) -->
        <section id="timer" class="mode-panel p-6 rounded-2xl mode-card hidden transition-opacity duration-500 ease-in-out">
          <div class="flex items-center justify-between">
            <div>
              <h2 class="text-xl font-bold">Timer</h2>
              <p class="text-slate-300 text-sm">Portrait Upside Down — Countdown timer</p>
            </div>
            <div class="text-cyan-300 font-mono text-2xl" id="timerDisplay">00:00</div>
          </div>

          <div class="mt-4 grid grid-cols-3 gap-2">
            <input id="timerMin" type="number" min="0" placeholder="min" class="p-3 rounded-lg glass-btn text-black" />
            <input id="timerSec" type="number" min="0" max="59" placeholder="sec" class="p-3 rounded-lg glass-btn text-black" />
            <button id="timerSet" class="p-3 rounded-lg text-white bg-cyan-500">Set & Start</button>
          </div>

          <div class="mt-3 flex gap-3">
            <button id="timerPause" class="flex-1 p-3 rounded-lg glass-btn">Pause</button>
            <button id="timerReset" class="flex-1 p-3 rounded-lg glass-btn">Reset</button>
          </div>
        </section>

        <!-- Weather (Landscape left) -->
        <section id="weather" class="mode-panel p-6 rounded-2xl mode-card hidden transition-opacity duration-500 ease-in-out">
          <div class="flex items-center justify-between">
            <div>
              <h2 class="text-xl font-bold">Weather of the Day</h2>
              <p class="text-slate-300 text-sm">Landscape — Local weather (OpenWeatherMap)</p>
            </div>
            <div id="weatherIcon" class="text-2xl">☁️</div>
          </div>

          <div class="mt-4">
            <div id="weatherCard" class="p-4 rounded-lg glass-btn">
              <div class="flex items-center justify-between">
                <div>
                  <div id="wCity" class="font-semibold">—</div>
                  <div id="wDesc" class="text-sm text-slate-300">—</div>
                </div>
                <div class="text-3xl font-mono" id="wTemp">--°C</div>
              </div>
              <div class="mt-3 text-sm text-slate-300">Updated: <span id="wUpdated">—</span></div>
            </div>
            <div class="mt-3 flex gap-3">
              <button id="refreshWeather" class="p-3 rounded-lg text-white bg-sky-500">Refresh</button>
              <button id="manualCityBtn" class="p-3 rounded-lg glass-btn">Change City</button>
            </div>
          </div>
        </section>

      </div>

      <footer class="text-xs text-slate-400 text-center mt-4">Built for "Prompt This Into Existence!" — rotate your device to interact. Replace the OpenWeatherMap key in the script.</footer>
    </main>
  </div>

  <audio id="alarmAudio" src="https://actions.google.com/sounds/v1/alarms/alarm_clock.ogg" preload="auto"></audio>

  <script>
    // ----------------------- Orientation Detection & Mode Switching -----------------------
    const modeTitle = document.getElementById('modeTitle');
    const modeSubtitle = document.getElementById('modeSubtitle');
    const angleDisplay = document.getElementById('angleDisplay');
    const orientationType = document.getElementById('orientationType');

    const panels = {
      alarm: document.getElementById('alarm'),
      stopwatch: document.getElementById('stopwatch'),
      timer: document.getElementById('timer'),
      weather: document.getElementById('weather')
    };

    let currentMode = null;

    function hideAll() {
      Object.values(panels).forEach(el => {
        el.classList.add('hidden');
      });
    }

    function show(mode) {
      if (currentMode === mode) return;
      hideAll();
      panels[mode].classList.remove('hidden');
      currentMode = mode;
    }

    function interpretAngle(angle) {
      // Normalize angle to 0..359
      angle = ((angle % 360) + 360) % 360;
      angleDisplay.textContent = 'angle: ' + angle;
      if ((angle >= 315 || angle < 45)) {
        orientationType.textContent = 'portrait-up';
        modeTitle.textContent = 'Portrait — Alarm';
        modeSubtitle.textContent = 'Upright orientation detected';
        show('alarm');
      } else if (angle >= 135 && angle < 225) {
        orientationType.textContent = 'portrait-down';
        modeTitle.textContent = 'Portrait — Timer';
        modeSubtitle.textContent = 'Upside down orientation detected';
        show('timer');
      } else if (angle >= 45 && angle < 135) {
        orientationType.textContent = 'landscape-right';
        modeTitle.textContent = 'Landscape — Stopwatch';
        modeSubtitle.textContent = 'Landscape (right-side up) detected';
        show('stopwatch');
      } else {
        orientationType.textContent = 'landscape-left';
        modeTitle.textContent = 'Landscape — Weather';
        modeSubtitle.textContent = 'Landscape (left-side up) detected — local weather';
        show('weather');
      }
    }

    function readAngle() {
      let angle = 0;
      if (screen.orientation && typeof screen.orientation.angle === 'number') angle = screen.orientation.angle;
      else if (typeof window.orientation === 'number') angle = window.orientation;
      interpretAngle(angle);
    }

    // Listen to orientation changes
    if (screen.orientation && screen.orientation.addEventListener) {
      screen.orientation.addEventListener('change', readAngle);
    } else {
      window.addEventListener('orientationchange', readAngle);
    }

    // Also poll on load and after short delays for devices that don't fire events reliably
    window.addEventListener('load', () => { readAngle(); setTimeout(readAngle, 500); setTimeout(readAngle, 1200); });

    // ----------------------- Alarm Implementation -----------------------
    const alarmTimeInput = document.getElementById('alarmTime');
    const setAlarmBtn = document.getElementById('setAlarmBtn');
    const alarmStatus = document.getElementById('alarmStatus');
    const alarmAudio = document.getElementById('alarmAudio');
    let alarmTimeout = null;

    function clearAlarm() {
      if (alarmTimeout) { clearTimeout(alarmTimeout); alarmTimeout = null; }
      alarmStatus.textContent = 'No alarm set';
    }

    setAlarmBtn.addEventListener('click', () => {
      const t = alarmTimeInput.value;
      if (!t) { alert('Pick a time first'); return; }
      const [hh, mm] = t.split(':').map(Number);
      const now = new Date();
      const alarm = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hh, mm, 0);
      if (alarm <= now) alarm.setDate(alarm.getDate() + 1); // next day
      const ms = alarm - now;
      if (alarmTimeout) clearTimeout(alarmTimeout);
      alarmTimeout = setTimeout(() => {
        alarmAudio.play();
        alarmStatus.textContent = 'Ringing!';
        // flash UI
        panels.alarm.classList.add('pulse');
        setTimeout(()=>panels.alarm.classList.remove('pulse'),5000);
      }, ms);
      alarmStatus.textContent = 'Alarm set for ' + alarm.toLocaleTimeString();
    });

    // ----------------------- Stopwatch -----------------------
    const swDisplay = document.getElementById('stopwatchDisplay');
    const swStart = document.getElementById('swStart');
    const swLap = document.getElementById('swLap');
    const swReset = document.getElementById('swReset');
    const lapsList = document.getElementById('laps');

    let swStartTime = 0, swElapsed = 0, swTimer = null;

    function formatSw(ms) {
      const total = Math.floor(ms);
      const minutes = Math.floor(total / 60000);
      const seconds = Math.floor((total % 60000) / 1000);
      const millis = total % 1000;
      return `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}.${String(millis).padStart(3,'0')}`;
    }

    function updateSw() {
      const now = Date.now();
      swElapsed = now - swStartTime;
      swDisplay.textContent = formatSw(swElapsed);
      swTimer = requestAnimationFrame(updateSw);
    }

    swStart.addEventListener('click', () => {
      if (!swTimer) {
        swStartTime = Date.now() - swElapsed;
        swTimer = requestAnimationFrame(updateSw);
        swStart.textContent = 'Pause';
      } else {
        cancelAnimationFrame(swTimer); swTimer = null; swStart.textContent = 'Start';
      }
    });

    swLap.addEventListener('click', () => {
      if (!swTimer) return;
      const li = document.createElement('li');
      li.textContent = `Lap ${lapsList.children.length + 1}: ${formatSw(swElapsed)}`;
      lapsList.prepend(li);
    });

    swReset.addEventListener('click', () => {
      cancelAnimationFrame(swTimer); swTimer = null; swElapsed = 0; swDisplay.textContent = '00:00.000'; swStart.textContent = 'Start'; lapsList.innerHTML = '';
    });

    // ----------------------- Timer -----------------------
    const timerMin = document.getElementById('timerMin');
    const timerSec = document.getElementById('timerSec');
    const timerSet = document.getElementById('timerSet');
    const timerPause = document.getElementById('timerPause');
    const timerReset = document.getElementById('timerReset');
    const timerDisplay = document.getElementById('timerDisplay');

    let timerRemaining = 0; // ms
    let timerInterval = null; // requestAnimationFrame id
    let timerLast = 0;

    function formatTimer(ms) {
      const s = Math.ceil(ms / 1000);
      const mm = Math.floor(s / 60);
      const ss = s % 60;
      return `${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
    }

    function tickTimer(now) {
      if (!timerLast) timerLast = now;
      const delta = now - timerLast; timerLast = now;
      timerRemaining -= delta;
      if (timerRemaining <= 0) {
        timerRemaining = 0; timerDisplay.textContent = '00:00';
        alarmAudio.play();
        cancelAnimationFrame(timerInterval); timerInterval = null; timerLast = 0;
        panels.timer.classList.add('pulse'); setTimeout(()=>panels.timer.classList.remove('pulse'),4000);
        return;
      }
      timerDisplay.textContent = formatTimer(timerRemaining);
      timerInterval = requestAnimationFrame(tickTimer);
    }

    timerSet.addEventListener('click', () => {
      const mm = Math.max(0, Number(timerMin.value) || 0);
      const ss = Math.max(0, Number(timerSec.value) || 0);
      timerRemaining = (mm * 60 + ss) * 1000;
      if (timerRemaining <= 0) { alert('Set a duration'); return; }
      cancelAnimationFrame(timerInterval); timerInterval = requestAnimationFrame(tickTimer);
      timerLast = 0; timerDisplay.textContent = formatTimer(timerRemaining);
    });

    timerPause.addEventListener('click', () => {
      if (timerInterval) { cancelAnimationFrame(timerInterval); timerInterval = null; timerLast = 0; timerPause.textContent = 'Resume'; }
      else if (timerRemaining > 0) { timerInterval = requestAnimationFrame(tickTimer); timerPause.textContent = 'Pause'; }
    });

    timerReset.addEventListener('click', () => { cancelAnimationFrame(timerInterval); timerInterval = null; timerRemaining = 0; timerDisplay.textContent = '00:00'; timerLast = 0; });

    // ----------------------- Weather -----------------------
    // Replace with your OpenWeatherMap API key
    const OWM_KEY = 'YOUR_OPENWEATHERMAP_API_KEY';
    const wCity = document.getElementById('wCity');
    const wDesc = document.getElementById('wDesc');
    const wTemp = document.getElementById('wTemp');
    const wUpdated = document.getElementById('wUpdated');
    const weatherIcon = document.getElementById('weatherIcon');

    async function fetchWeatherByCoords(lat, lon) {
      if (!OWM_KEY || OWM_KEY === 'YOUR_OPENWEATHERMAP_API_KEY') {
        wCity.textContent = 'Provide OWM API key in the source'; wDesc.textContent = ''; wTemp.textContent = '--°C'; return;
      }
      try {
        const res = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&units=metric&appid=${OWM_KEY}`);
        const data = await res.json();
        renderWeather(data);
      } catch (e) {
        wCity.textContent = 'Unable to fetch weather'; wDesc.textContent = e.message; wTemp.textContent = '--°C';
      }
    }

    async function fetchWeatherByCity(q) {
      if (!OWM_KEY || OWM_KEY === 'YOUR_OPENWEATHERMAP_API_KEY') { wCity.textContent = 'Provide OWM API key in the source'; return; }
      try {
        const res = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(q)}&units=metric&appid=${OWM_KEY}`);
        const data = await res.json();
        renderWeather(data);
      } catch (e) {
        wCity.textContent = 'Unable to fetch weather'; wDesc.textContent = e.message; wTemp.textContent = '--°C';
      }
    }

    function renderWeather(data) {
      if (!data || data.cod && data.cod !== 200) { wCity.textContent = 'Location not found'; wDesc.textContent = JSON.stringify(data); return; }
      wCity.textContent = `${data.name}, ${data.sys?.country || ''}`;
      const desc = data.weather?.[0]?.description || '—';
      wDesc.textContent = desc;
      wTemp.textContent = Math.round(data.main?.temp) + '°C';
      wUpdated.textContent = new Date(data.dt * 1000).toLocaleString();
      const icon = data.weather?.[0]?.icon || '';
      weatherIcon.textContent = iconToEmoji(icon);
    }

    function iconToEmoji(icon) {
      if (!icon) return '—';
      const code = icon.slice(0,2);
      switch(code) {
        case '01': return '☀️';
        case '02': return '🌤️';
        case '03': return '☁️';
        case '04': return '☁️';
        case '09': return '🌧️';
        case '10': return '🌦️';
        case '11': return '⛈️';
        case '13': return '❄️';
        case '50': return '🌫️';
        default: return '🌡️';
      }
    }

    document.getElementById('refreshWeather').addEventListener('click', () => getWeatherForDevice());
    document.getElementById('manualCityBtn').addEventListener('click', async () => {
      const q = prompt('Enter city name (e.g. London, UK):'); if (!q) return; await fetchWeatherByCity(q);
    });

    function getWeatherForDevice() {
      if (!navigator.geolocation) { wCity.textContent = 'Geolocation not supported'; return; }
      navigator.geolocation.getCurrentPosition((p) => {
        fetchWeatherByCoords(p.coords.latitude, p.coords.longitude);
      }, (err) => {
        wCity.textContent = 'Location permission denied';
      }, {timeout:8000});
    }

    // Auto-refresh weather on showing panel
    const observer = new MutationObserver((mutations) => {
      for (const m of mutations) {
        if (m.type === 'attributes' && m.attributeName === 'class') {
          const el = m.target;
          if (el === panels.weather && !el.classList.contains('hidden')) {
            getWeatherForDevice();
          }
        }
      }
    });
    observer.observe(panels.weather, { attributes: true });

    // ----------------------- Friendly touch guidance / fallback -----------------------
    // If screen.orientation APIs are missing, try to map angle via DeviceOrientationEvent
    if (!('orientation' in screen) && typeof DeviceOrientationEvent !== 'undefined') {
      // Ask permissions on iOS 13+ if necessary
      if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().catch(()=>{}).then(()=>{});
      }
      window.addEventListener('deviceorientation', (ev)=>{
        // use gamma (left-right) and beta (front-back) heuristics only if screen.orientation missing
        // Not as reliable — we fallback to polling readAngle where possible
        // Convert to an angle-like heuristic
        const gamma = ev.gamma || 0; // -90 to 90
        const beta = ev.beta || 0; // -180 to 180
        // heuristics: upright portrait when |gamma| < 30 and beta > 0
        if (Math.abs(gamma) < 30 && beta > 10) interpretAngle(0);
        else if (Math.abs(gamma) < 30 && beta < -100) interpretAngle(180);
        else if (gamma > 20) interpretAngle(90);
        else if (gamma < -20) interpretAngle(270);
      });
    }

  </script>
</body>
</html>
