<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Prompt This Into Existence — Orientation Time Utilities</title>

<!-- PWA Manifest hint (optional file to add later) -->
<link rel="manifest" href="/manifest.json" />

<!-- Basic styling + mobile-first UI -->
<style>
  :root{
    --bg:#0f1724; --card:#0b1220; --accent:#7c3aed; --muted:#9aa4b2; --glass: rgba(255,255,255,0.04);
    --success: #10b981; --danger:#ef4444;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{
    background: radial-gradient(1200px 600px at 10% 10%, rgba(124,58,237,0.10), transparent 10%),
                radial-gradient(800px 400px at 90% 90%, rgba(16,185,129,0.06), transparent 10%),
                var(--bg);
    color:#e6eef8; display:flex; align-items:center; justify-content:center;
    padding:20px;
  }
  .app{
    width:100%; max-width:520px; min-height:640px; background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    border-radius:18px; box-shadow: 0 10px 40px rgba(2,6,23,0.7); overflow:hidden; position:relative;
    -webkit-tap-highlight-color: transparent;
  }

  header{
    display:flex; align-items:center; gap:12px; padding:16px 18px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-bottom:1px solid rgba(255,255,255,0.03);
  }
  .logo{width:42px;height:42px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#06b6d4);display:flex;align-items:center;justify-content:center;font-weight:700;}
  .title{font-weight:600;font-size:16px}
  .subtitle{font-size:12px;color:var(--muted); margin-top:2px}

  main{padding:22px; display:flex; flex-direction:column; gap:18px;}
  .orientation-card{background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent); border-radius:14px; padding:14px; display:flex; align-items:center; justify-content:space-between; gap:12px;}
  .orientation-card .left{display:flex;flex-direction:column;}
  .big-state{font-size:14px; font-weight:700}
  .small{font-size:12px;color:var(--muted)}

  /* containers for components */
  .stage{position:relative; height:380px; border-radius:12px; overflow:hidden; background: linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); display:flex; align-items:center; justify-content:center;}
  .feature{
    position:absolute; inset:0; padding:18px; display:flex; flex-direction:column; align-items:center; justify-content:center;
    transition: transform 420ms cubic-bezier(.2,.9,.2,1), opacity 320ms ease;
    opacity:0; transform:translateY(18px) scale(.99);
    pointer-events:none;
    backface-visibility:hidden;
  }
  .feature.active{ opacity:1; transform:none; pointer-events:auto; }

  /* Alarm style */
  .alarm-clock .time{font-size:56px; font-weight:700; letter-spacing:1px; margin-bottom:12px;}
  .alarm-controls{display:flex; gap:8px; align-items:center;}
  input[type="time"]{font-size:16px;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04); background:var(--glass); color:inherit;}

  /* Stopwatch */
  .stopwatch .display{font-size:48px; font-weight:700; letter-spacing:0.5px; margin-bottom:14px;}
  .btn-row{display:flex; gap:10px;}
  button{background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); padding:10px 14px;border-radius:10px;color:inherit;font-weight:600;}
  button.primary{background:linear-gradient(90deg,var(--accent),#06b6d4); color:#062024; border:none; box-shadow:0 6px 18px rgba(12,28,52,0.4);}
  .danger{background:linear-gradient(90deg,var(--danger),#ff7a7a); color:white; border:none;}

  /* Timer */
  .timer .inputs{display:flex; gap:8px; margin-bottom:12px;}
  .number-input{width:110px;text-align:center;font-size:22px;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04); background:var(--glass);}

  /* Weather */
  .weather .big-temp{font-size:56px;font-weight:800;margin-bottom:6px;}
  .weather .cond{font-size:16px;color:var(--muted); margin-bottom:12px;}
  .weather .meta{font-size:13px;color:var(--muted);}

  footer{padding:12px 18px; display:flex; justify-content:space-between; gap:8px; align-items:center; border-top:1px solid rgba(255,255,255,0.03);}
  .mini{font-size:12px;color:var(--muted)}
  .chip{font-size:12px;background:rgba(255,255,255,0.02);padding:8px;border-radius:10px;}
  .hint{font-size:12px;color:var(--muted);}

  /* responsive tiny touches */
  @media (max-width:420px){
    .alarm-clock .time{font-size:46px}
    .weather .big-temp{font-size:48px}
    .stage{height:360px}
  }
</style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <div class="logo">PT</div>
      <div>
        <div class="title">Prompt This Into Existence</div>
        <div class="subtitle">Orientation-driven Alarm • Stopwatch • Timer • Weather</div>
      </div>
      <div style="margin-left:auto" class="chip" id="orientationIndicator">Detecting…</div>
    </header>

    <main>
      <div class="orientation-card">
        <div class="left">
          <div class="big-state">Current Orientation</div>
          <div class="small" id="orientationLabel">—</div>
        </div>
        <div class="small">Flip your phone to switch tools</div>
      </div>

      <div class="stage" id="stage">
        <!-- ALARM (Portrait Upright) -->
        <section class="feature alarm-clock" id="alarm" aria-hidden="true">
          <div style="text-align:center">
            <div class="time" id="alarmTimeDisplay">--:--:--</div>
            <div class="small" style="margin-bottom:10px">Alarm (portrait upright)</div>
            <div class="alarm-controls">
              <input type="time" id="alarmInput" />
              <button id="setAlarmBtn" class="primary">Set</button>
              <button id="clearAlarmBtn" class="danger">Clear</button>
            </div>
            <div class="small" style="margin-top:12px">Saved alarm: <span id="savedAlarm">—</span></div>
          </div>
        </section>

        <!-- STOPWATCH (Landscape Right, assumed primary) -->
        <section class="feature stopwatch" id="stopwatch" aria-hidden="true">
          <div style="text-align:center">
            <div class="display" id="swDisplay">00:00:00</div>
            <div class="btn-row">
              <button id="swStart" class="primary">Start</button>
              <button id="swStop">Stop</button>
              <button id="swReset" class="">Reset</button>
            </div>
            <div class="small" style="margin-top:12px">Landscape — stopwatch</div>
          </div>
        </section>

        <!-- TIMER (Portrait Upside-down) -->
        <section class="feature timer" id="timer" aria-hidden="true">
          <div style="text-align:center">
            <div class="display" id="timerDisplay">00:00</div>
            <div class="inputs" style="justify-content:center;">
              <input type="number" min="0" max="999" placeholder="Minutes" id="timerMinutes" class="number-input" />
              <input type="number" min="0" max="59" placeholder="Seconds" id="timerSeconds" class="number-input" />
            </div>
            <div class="btn-row">
              <button id="tStart" class="primary">Start</button>
              <button id="tStop">Stop</button>
              <button id="tReset">Reset</button>
            </div>
            <div class="small" style="margin-top:12px">Portrait upside-down — timer</div>
          </div>
        </section>

        <!-- WEATHER (Landscape Left, assumed secondary) -->
        <section class="feature weather" id="weather" aria-hidden="true">
          <div style="text-align:center">
            <div class="big-temp" id="weatherTemp">--°</div>
            <div class="cond" id="weatherCond">Weather of the day</div>
            <div class="meta" id="weatherMeta">Get location to fetch weather</div>
            <div style="margin-top:12px">
              <button id="refreshWeather">Refresh</button>
              <button id="locWeather" class="">Use My Location</button>
            </div>
            <div class="small" style="margin-top:12px">Landscape — weather</div>
          </div>
        </section>
      </div>
    </main>

    <footer>
      <div class="mini">Made for the hackathon • <span id="wowBadge" class="chip">Wow: haptics + offline-ready</span></div>
      <div class="hint" id="notes">Tip: rotate your phone now →</div>
    </footer>
  </div>

<!-- Audio cues (base64 tiny beep) -->
<audio id="alarmSound" src="data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAA" preload="auto"></audio>

<script>
/*
  Orientation-first app main JS
  - Screen Orientation API preferred
  - Fallback to window.orientation (legacy)
  - deviceorientation as last-resort fallback (best-effort; iOS permission-needed)
  - Map to four cases: upright, upside-down, landscape-right, landscape-left
*/

/* ---------- Configuration ---------- */
const OPENWEATHER_API_KEY = 'YOUR_OPENWEATHER_API_KEY'; // <<--- INSERT your API key here
const WEATHER_UNITS = 'metric'; // or 'imperial'

/* ---------- UI refs ---------- */
const orientationLabel = document.getElementById('orientationLabel');
const orientationIndicator = document.getElementById('orientationIndicator');
const alarmDiv = document.getElementById('alarm');
const stopwatchDiv = document.getElementById('stopwatch');
const timerDiv = document.getElementById('timer');
const weatherDiv = document.getElementById('weather');
const stage = document.getElementById('stage');

const savedAlarmElem = document.getElementById('savedAlarm');
const alarmInput = document.getElementById('alarmInput');
const setAlarmBtn = document.getElementById('setAlarmBtn');
const clearAlarmBtn = document.getElementById('clearAlarmBtn');
const alarmTimeDisplay = document.getElementById('alarmTimeDisplay');
const alarmSound = document.getElementById('alarmSound');

const swDisplay = document.getElementById('swDisplay');
const swStart = document.getElementById('swStart');
const swStop = document.getElementById('swStop');
const swReset = document.getElementById('swReset');

const timerDisplay = document.getElementById('timerDisplay');
const tStart = document.getElementById('tStart');
const tStop = document.getElementById('tStop');
const tReset = document.getElementById('tReset');
const timerMinutes = document.getElementById('timerMinutes');
const timerSeconds = document.getElementById('timerSeconds');

const weatherTemp = document.getElementById('weatherTemp');
const weatherCond = document.getElementById('weatherCond');
const weatherMeta = document.getElementById('weatherMeta');
const refreshWeather = document.getElementById('refreshWeather');
const locWeather = document.getElementById('locWeather');

const orientationEls = {
  'upright': alarmDiv,
  'upside-down': timerDiv,
  'landscape-right': stopwatchDiv,
  'landscape-left': weatherDiv
};

/* ---------- App state ---------- */
let currentOrientation = null;
let alarmTimeStr = localStorage.getItem('pt_alarm_time') || null;
if(alarmTimeStr) { savedAlarmElem.textContent = alarmTimeStr; alarmInput.value = alarmTimeStr; }

let swInterval=null, swStartTs=null, swAccum=0; // stopwatch
let timerInterval=null, timerEndTs=null; // timer

/* ---------- Utility: show/hide features ---------- */
function showFeatureFor(orientation) {
  currentOrientation = orientation;
  orientationLabel.textContent = orientation;
  orientationIndicator.textContent = orientation;
  // hide all, then show the right one with animation
  Object.values(orientationEls).forEach(el => { el.classList.remove('active'); el.setAttribute('aria-hidden', 'true'); });
  const el = orientationEls[orientation];
  if(el){
    el.classList.add('active');
    el.setAttribute('aria-hidden', 'false');
  }
  // optional haptic feedback
  if (navigator.vibrate) navigator.vibrate(30);
}

/* ---------- Alarm implementation ---------- */
function formatTime(date) {
  return date.toLocaleTimeString([], { hour12:false });
}
function updateClockDisplay(){
  alarmTimeDisplay.textContent = formatTime(new Date());
}
setInterval(updateClockDisplay, 1000);
updateClockDisplay();

setAlarmBtn.addEventListener('click', () => {
  const v = alarmInput.value;
  if(!v){ alert('Pick a time'); return; }
  // Browser time input returns "HH:MM", convert to HH:MM:SS assumed 00
  alarmTimeStr = v.length===5 ? `${v}:00` : v;
  localStorage.setItem('pt_alarm_time', alarmTimeStr);
  savedAlarmElem.textContent = alarmTimeStr;
  flashUI('Alarm set for ' + alarmTimeStr);
});
clearAlarmBtn.addEventListener('click', () => {
  alarmTimeStr = null;
  localStorage.removeItem('pt_alarm_time');
  savedAlarmElem.textContent = '—';
  flashUI('Alarm cleared');
});

/* Check alarm every second */
setInterval(() => {
  if(!alarmTimeStr) return;
  const now = formatTime(new Date());
  if(now === alarmTimeStr){
    // ring! play sound, vibrate, show big visual
    triggerAlarm();
    // to avoid repeating every second, clear saved alarm (optional)
    // localStorage.removeItem('pt_alarm_time'); alarmTimeStr=null; savedAlarmElem.textContent='—';
  }
}, 1000);

function triggerAlarm(){
  flashScreen('Alarm!', 2200);
  if(alarmSound){
    try{ alarmSound.play(); } catch(e){ /* may require user interaction */ }
  }
  if(navigator.vibrate) navigator.vibrate([200,80,150]);
}

/* ---------- Stopwatch implementation ---------- */
function formatElapsed(ms) {
  const cs = Math.floor(ms/10)%100;
  const s = Math.floor(ms/1000)%60;
  const m = Math.floor(ms/60000);
  return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}:${String(cs).padStart(2,'0')}`;
}
swStart.addEventListener('click', () => {
  if(swInterval) return;
  swStartTs = Date.now();
  swInterval = setInterval(()=> {
    const now = Date.now();
    const elapsed = swAccum + (now - swStartTs);
    swDisplay.textContent = formatElapsed(elapsed);
  }, 50);
});
swStop.addEventListener('click', () => {
  if(!swInterval) return;
  clearInterval(swInterval); swInterval=null;
  swAccum += Date.now() - swStartTs;
  swStartTs = null;
});
swReset.addEventListener('click', () => {
  clearInterval(swInterval); swInterval=null; swStartTs=null; swAccum=0;
  swDisplay.textContent='00:00:00';
});

/* ---------- Timer implementation ---------- */
function formatRemaining(ms){
  if(ms<=0) return '00:00';
  const s = Math.floor(ms/1000)%60;
  const m = Math.floor(ms/60000);
  return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
}
tStart.addEventListener('click', () => {
  const m = Number(timerMinutes.value) || 0;
  const s = Number(timerSeconds.value) || 0;
  const totalMs = (m*60 + s)*1000;
  if(totalMs<=0) { alert('Enter a duration'); return; }
  timerEndTs = Date.now() + totalMs;
  if(timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(()=> {
    const rem = timerEndTs - Date.now();
    timerDisplay.textContent = formatRemaining(rem);
    if(rem<=0){
      clearInterval(timerInterval); timerInterval=null;
      timerDisplay.textContent='00:00';
      flashScreen('Timer done!', 2000);
      if(navigator.vibrate) navigator.vibrate([200,100,200]);
    }
  }, 250);
});
tStop.addEventListener('click', () => {
  if(timerInterval){ clearInterval(timerInterval); timerInterval=null; }
});
tReset.addEventListener('click', () => {
  if(timerInterval){ clearInterval(timerInterval); timerInterval=null; }
  timerDisplay.textContent='00:00';
});

/* ---------- Weather implementation ---------- */
async function fetchWeatherByCoords(lat, lon) {
  if(!OPENWEATHER_API_KEY || OPENWEATHER_API_KEY==='YOUR_OPENWEATHER_API_KEY'){
    weatherCond.textContent = 'Add API key in code';
    return;
  }
  weatherMeta.textContent = 'Fetching…';
  try{
    const url = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&units=${WEATHER_UNITS}&appid=${OPENWEATHER_API_KEY}`;
    const res = await fetch(url);
    if(!res.ok) throw new Error('Weather API error');
    const j = await res.json();
    const temp = Math.round(j.main.temp);
    weatherTemp.textContent = `${temp}°`;
    weatherCond.textContent = `${j.weather[0].main} — ${j.weather[0].description}`;
    weatherMeta.textContent = `${j.name} • Humidity ${j.main.humidity}%`;
    flashUI('Weather updated');
  }catch(e){
    weatherMeta.textContent = 'Weather unavailable';
    console.error(e);
  }
}
refreshWeather.addEventListener('click', () => {
  // if we have cached coords ask to use them, else ask for location
  if(localStorage.getItem('pt_coords')){
    const {lat, lon} = JSON.parse(localStorage.getItem('pt_coords'));
    fetchWeatherByCoords(lat, lon);
  } else {
    fetchLocationAndWeather();
  }
});
locWeather.addEventListener('click', fetchLocationAndWeather);

function fetchLocationAndWeather(){
  if(!navigator.geolocation){ weatherMeta.textContent='Geolocation unsupported'; return; }
  navigator.geolocation.getCurrentPosition((pos)=>{
    const lat = pos.coords.latitude, lon = pos.coords.longitude;
    localStorage.setItem('pt_coords', JSON.stringify({lat,lon}));
    fetchWeatherByCoords(lat, lon);
  }, (err)=>{
    weatherMeta.textContent = 'Location permission denied';
  }, {enableHighAccuracy:false, timeout:8000});
}

/* ---------- Helpful small UI helpers ---------- */
function flashUI(text){
  const prev = document.getElementById('tempToast');
  if(prev) prev.remove();
  const t = document.createElement('div');
  t.id='tempToast';
  t.style.position='absolute'; t.style.left='50%'; t.style.top='12%'; t.style.transform='translateX(-50%)';
  t.style.background='linear-gradient(90deg,var(--accent),#06b6d4)'; t.style.color='#042226'; t.style.padding='10px 16px';
  t.style.borderRadius='10px'; t.style.fontWeight=700; t.style.boxShadow='0 8px 30px rgba(2,6,23,0.6)';
  t.innerText = text;
  stage.appendChild(t);
  setTimeout(()=> t.remove(), 1700);
}
function flashScreen(text, ms=1500){
  const overlay = document.createElement('div');
  overlay.style.position='absolute'; overlay.style.inset=0; overlay.style.display='flex'; overlay.style.alignItems='center'; overlay.style.justifyContent='center';
  overlay.style.background='linear-gradient(180deg, rgba(124,58,237,0.18), rgba(6,182,212,0.12))'; overlay.style.color='#fff';
  overlay.style.fontSize='28px'; overlay.style.fontWeight=800; overlay.style.zIndex=50;
  overlay.innerText = text;
  stage.appendChild(overlay);
  setTimeout(()=> overlay.remove(), ms);
}

/* ---------- Orientation detection: robust hybrid ---------- */

/*
  Strategy:
  1) Try Screen.orientation.type (best).
  2) Else fallback to window.orientation (legacy angle) via orientationchange.
  3) Else as last resort, use deviceorientation (beta/gamma) — best-effort and prompts for iOS permission.
  4) Also listen to resize as an additional signal.
*/

function mapOrientationFromType(otype){
  if(!otype) return null;
  otype = otype.toLowerCase();
  if(otype.includes('portrait-primary')) return 'upright';
  if(otype.includes('portrait-secondary')) return 'upside-down';
  if(otype.includes('landscape-primary')) return 'landscape-right';
  if(otype.includes('landscape-secondary')) return 'landscape-left';
  // some browsers return 'portrait' or 'landscape' only:
  if(otype === 'portrait') return (window.innerHeight > window.innerWidth) ? 'upright' : 'upright';
  if(otype === 'landscape') return (window.innerWidth > window.innerHeight) ? 'landscape-right' : 'landscape-right';
  return null;
}
function mapOrientationFromAngle(angle){
  // window.orientation values: 0, 90, -90, 180 (and sometimes 270)
  angle = Number(angle);
  angle = ((angle % 360) + 360) % 360; // normalize 0..359
  if(angle === 0) return 'upright';
  if(angle === 180) return 'upside-down';
  if(angle === 90) return 'landscape-right'; // device rotated clockwise
  if(angle === 270) return 'landscape-left';
  return null;
}

/* Deviceorientation fallback: we read beta (tilt front-back, -180..180) and gamma (left-right, -90..90)
   This mapping is approximate and used only when other APIs unavailable.
   Heuristics:
     - portrait upright: |gamma| < ~30 and |beta| < ~60 and screen taller than wide
     - portrait upside-down: |gamma| < ~30 and |beta| > ~120 (or < -120) ? or reversed sign
     - landscape-right: gamma > ~30
     - landscape-left: gamma < -30
   Note: deviceorientation varies per device; this is best-effort.
*/
let deviceOrSupported = false;
function deviceOrientationHandler(e){
  deviceOrSupported = true;
  const beta = e.beta; // -180 .. 180 (front-back tilt)
  const gamma = e.gamma; // -90 .. 90 (left-right tilt)
  // use gamma to pick left/right landscape
  if(gamma > 30) { setOrientationIfChanged('landscape-right'); return; }
  if(gamma < -30) { setOrientationIfChanged('landscape-left'); return; }
  // if near vertical and phone taller than wide, decide portrait upright/upside-down via beta
  if(Math.abs(gamma) <= 30){
    if(beta > 100 || beta < -100){ setOrientationIfChanged('upside-down'); return; }
    setOrientationIfChanged('upright'); return;
  }
}

/* central setter w/ debounce */
let lastOrientationSet = null;
function setOrientationIfChanged(o){
  if(o === lastOrientationSet) return;
  lastOrientationSet = o;
  showFeatureFor(o);
}

/* main detection sequence */
async function detectOrientationInit(){
  // 1) Screen Orientation API
  if(screen.orientation && screen.orientation.type){
    const o = mapOrientationFromType(screen.orientation.type);
    if(o) setOrientationIfChanged(o);
    screen.orientation.addEventListener('change', () => {
      const o2 = mapOrientationFromType(screen.orientation.type);
      if(o2) setOrientationIfChanged(o2);
    });
  }

  // 2) legacy window.orientation / orientationchange
  window.addEventListener('orientationchange', () => {
    const ang = (screen.orientation && typeof screen.orientation.angle === 'number') ? screen.orientation.angle : (typeof window.orientation === 'number' ? window.orientation : null);
    const mapped = mapOrientationFromAngle(ang);
    if(mapped) setOrientationIfChanged(mapped);
  });

  // 3) resize fallback (some browsers only change innerWidth/innerHeight)
  window.addEventListener('resize', () => {
    // prefer other APIs, but as fallback: decide by innerWidth/innerHeight and preserve last left/right via angle if available
    const isPortrait = window.innerHeight > window.innerWidth;
    if(isPortrait){
      // decide upright vs upside-down using previous angle if available
      const ang = (typeof window.orientation === 'number') ? mapOrientationFromAngle(window.orientation) : null;
      setOrientationIfChanged(ang || 'upright');
    } else {
      // prefer previous left/right
      const ang = (typeof window.orientation === 'number') ? mapOrientationFromAngle(window.orientation) : null;
      setOrientationIfChanged(ang || 'landscape-right');
    }
  });

  // 4) deviceorientation best-effort (ask permission on iOS)
  if(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
    // iOS 13+ requires user gesture to request permission. We'll prompt the user via an inline dialog if needed.
    // For hackathon rapid demo, ask permission on first touch.
    document.addEventListener('touchstart', async function iosDevicePermission(){
      try{
        const perm = await DeviceOrientationEvent.requestPermission();
        if(perm === 'granted'){
          window.addEventListener('deviceorientation', deviceOrientationHandler);
        }
      }catch(e){ console.log('device orientation perm err', e); }
      document.removeEventListener('touchstart', iosDevicePermission);
    }, {once:true});
  } else if(window.DeviceOrientationEvent){
    window.addEventListener('deviceorientation', deviceOrientationHandler);
  }

  // initial attempt using screen.orientation or window.orientation
  const initialAngle = (screen.orientation && typeof screen.orientation.angle === 'number') ? screen.orientation.angle : (typeof window.orientation === 'number' ? window.orientation : null);
  let initial = null;
  if(initialAngle !== null){
    initial = mapOrientationFromAngle(initialAngle);
  } else if(screen.orientation && screen.orientation.type){
    initial = mapOrientationFromType(screen.orientation.type);
  } else {
    // fallback using screen dimensions
    initial = window.innerHeight>window.innerWidth ? 'upright' : 'landscape-right';
  }
  setOrientationIfChanged(initial);
}

/* ---------- Boot ---------- */
detectOrientationInit();

/* ---------- Small niceties: show stage initially if orientation already known ---------- */
setTimeout(()=> {
  if(!currentOrientation) setOrientationIfChanged(window.innerHeight>window.innerWidth ? 'upright' : 'landscape-right');
}, 400);

/* ---------- Extra: service worker register stub (offline/PWA wow factor) ---------- */
if('serviceWorker' in navigator){
  navigator.serviceWorker.register('/sw.js').then(()=> {
    console.log('sw registered (if you add a /sw.js)');
  }).catch(()=>{});
}

/* ---------- Optional: quick demo helper to show orientation names clickable (for desktop demo) ---------- */
if(window.location.search.includes('demo')){
  ['upright','upside-down','landscape-right','landscape-left'].forEach(o=>{
    const b = document.createElement('button'); b.textContent=o; b.style.margin='6px';
    b.onclick=()=> setOrientationIfChanged(o);
    document.querySelector('footer .mini').appendChild(b);
  });
}
</script>
</body>
</html>
